В Phantom Shell будет возможность работать с объектами. По большей части, это будет выглядить в стиле Java, так как там это прекрасно организовано. Введение объектов обусловлено их удобством для организации кода многоразового пользования.

ОБЪЕКТНЫЕ ФАЙЛЫ
Код объектных классов будет храниться в специальных объектных файлах или библиотеках. Пользователь сможет как использовать набор готовых библиотек, так и создавать собственные.

Класс определяется с помощью ключевого слова сlass:
class Shell{

}

После названия класса идут фигурные скобки, в которых мы определяем конструкторы, методы и поля класса:
class Cat{
	Cat()//конструктор
	{
		
	}
	String name; //
	int age; // поля
	void printAge() //метод
	{
		print(age);
	}
}

Мы можем наследовать классы с помощью ключевого слова extends
class BengalCat extends Cat{
	BengalCat()
	{
		this.pattern = 'Spotted';
	}
	String pattern;
}


ССЫЛКИ
В следующем выражении:
def <object-type> linkName = new <object-type>;
левая половина означает объявление ссылки типа <object-type>, правая половина - создание экземпляра типа <object-type>. По итогу, ссылке присваивается адрес соответствующего объекта.
На один и тот же объект может ссылаться несколько ссылок или же ни одной (если такое произойдёт, то доступ к объекты будет утерян и его соберёт Garbage Collector).

Примеры различных конструкций:
def <object-type> linkName2 = linkName; // создать новую ссылку на объект,
					// на который указывает ссылка linkName

linkName2 = null; // переставить ссылку на специальный нулевой объект

Вызов атрибутов и методов объектов традиционно работает через точку.
def result1 = linkName.function[arg1, arg2];
def result2 = linkName.attribute;
linkName.procedure[];


STATIC
Предполагается, что статичные методы и поля будут удобны для хранения различных констант и их импорта в скрипты, ведь их можно использовать без необходимости создания экземпляра класса. Например:
class Math {
	def static const pi = 3.14159265358979323846; // статичная константа числа пи
	def static const e = 2.71828;                 // статичная константа числа Эйлера
	def static eps = 1e-9;			      // статичное число, задающее точность вычислений (не константа => можно изменить)
	def static const root2 = sRoot[2];   	      // статичная константа квадратного корня из 2
	
	static abs[x] { // статичная функция, возвращающая абсолютное значения числа x
		if (x > -eps) {
			return x;
		} else {
			return -x;
		}
	}

	static sRoot[x] { // статичная функция, возвращающая квадратный корень из x
		...		
	}
	...
}

Внутри скрипта:
...
import Math;		     // импортируем библиотеку с нужными классами

def x = Math.pi * 2;         // объявляем переменную, используя статичные атрибуты класса Math
def multiplier = someFunc[];

x -= Math.e * multiplier;
Math.eps = 1e-7;	     // меняем точность вычислений, так как это не константа
x = Math.abs(x);	     // получаем модуль числа x
...

Заметим, что из статичных методов вызов нестатичных методов и полей запрещён, поскольку для этого обязательно наличие экземпляра класса, которого может не существовать. В то же время, вызов статичных полей и методов можно производить не только по названию класса, но и через ссылку на экземлпяр объекта.
def Math link = new Math;
def e1 = Math.e;
def e2 = link.e;
// e1 == e2